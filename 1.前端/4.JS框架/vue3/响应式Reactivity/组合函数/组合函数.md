# 组合函数

## 概述

  - 在 Vue 应用的概念中，“组合式函数”是一个利用 Vue 组合式 API 来封装和复用**有状态逻辑**的函数。

  - 当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间而抽取一个可复用的函数。这个格式化函数封装了**无状态的逻辑**：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，诸如你可能听到过的 [lodash](https://lodash.com/ "lodash") 和 [date-fns](https://date-fns.org/ "date-fns")。

  - 相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在真实应用中，它也可以是像触摸手势或与数据库的连接状态这样的更复杂的逻辑

## 命名

  - 组合式函数约定用驼峰命名法命名，并以“**use**”作为开头

## 输入参数

  - 尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数。如果编写的组合式函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。[unref()](https://staging-cn.vuejs.org/api/reactivity-utilities.html#unref "unref()") 工具函数会对此非常有帮助

    ```javascript
    import { unref } from 'vue'

    function useFeature(maybeRef) {
      // 若 maybeRef 确实是一个 ref，它的 .value 会被返回
      // 否则，maybeRef 会被原样返回
      const value = unref(maybeRef)
    }
    ```

  - 如果你的组合式函数在接收 ref 为参数时会产生响应式 effect，请确保使用 `watch()` 显式地监听此 ref，或者在 `watchEffect()` 中调用 `unref()` 来进行正确的追踪

## 返回值

  - 合式函数中使用 `ref()` 而不是 `reactive()`

  - 推荐的约定是组合式函数始终返回一个 ref 对象，这样该函数在组件中解构之后仍可以保持响应性

    ```javascript
    // x 和 y 是两个 ref
    const { x, y } = useMouse()
    ```

    ```javascript
    function usePos(){
      const pos = reactive({ x:0, y:0 });
      return toRefs(pos); //  {x: refObj, y: refObj}
    }

    function useBooks(){
      const books = ref([]);
      return {
        books // books is refObj
      }
    }

    function useLoginUser(){
      const user = readonly({
        isLogin: false,
        loginId: null
      });
      return toRefs(user); // { isLogin: refObj, loginId: refObj }  all ref is readonly
    }

    setup(){
      // 在setup函数中，尽量保证解构、展开出来的所有响应式数据均是ref
      return {
        ...usePos(),
        ...useBooks(),
        ...useLoginUser()
      }
    }
    ```

## 副作用

  - 在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则

      - 如果你在一个应用中使用了[服务器端渲染](https://staging-cn.vuejs.org/guide/scaling-up/ssr.html "服务器端渲染") (SSR)，请确保在后置加载的声明钩子上执行 DOM 相关的副作用，例如：`onMounted()`。这些钩子仅会在浏览器中使用，因此可以确保能访问到 DOM

      - 确保在 `onUnmounted()` 时清理副作用。举个例子，如果一个组合式函数设置了一个事件监听器，它就应该在 `onUnmounted()` 中被移除。当然也可以像之前的 `useEventListener()` 示例那样，使用一个组合式函数来自动帮你做这些事

## 使用限制

  - 组合式函数在 `<script setup>` 或 `setup()` 钩子中，应始终被**同步地**调用。在某些场景下，你也可以在像 `onMounted()` 这样的生命周期钩子中使用他们。

  - 这些是 Vue 得以确定当前活跃的组件实例的条件。有能力对活跃的组件实例进行访问是必要的，以便：

    1.  可以在组合式函数中注册生命周期钩子

    2.  计算属性和监听器可以连接到当前组件实例，以便在组件卸载时处理掉

## 为更好的代码组织抽取组合式函数

  - 抽取组合式函数不仅是为了复用，也是为了代码组织

  - 随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解

  - 组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数

    ```vue
    <script setup>
    import { useFeatureA } from './featureA.js'
    import { useFeatureB } from './featureB.js'
    import { useFeatureC } from './featureC.js'

    const { foo, bar } = useFeatureA()
    const { baz } = useFeatureB(foo)
    const { qux } = useFeatureC(baz)
    </script>
    ```

  - 在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务
