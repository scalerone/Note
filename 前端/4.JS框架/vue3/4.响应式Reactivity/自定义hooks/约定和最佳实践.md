# 约定和最佳实践

## 命名规则

  - 以 `use` 开头。例如 `useApi`

## 输入的参数

  - 尽管响应性不依赖 `ref` ，可组合函数任可接收 `ref` 参数

  - 如果编写的可组合函数会被其他开发者使用，你最好在处理参数时兼容 `ref` 而不是只是原始值。 `unref()` 工具函数会对此非常有帮助

  - 如果可组合函数在接收 `ref` 为参数时会产生响应式 `effect`，请确保使用 `watch()` 显示监听此 `ref`，或者在 `watchEffect()` 中调用 `unref()` 来进行正确的追踪

## 返回值

  - 所有的 `composition function` 均以 `ref` 的结果返回（在组将中结构任然保持响应性）

  - 返回结果中不包含 `reactive`  或`readonly` 直接产生的数据

    ```js
    function usePos(){
      const pos = reactive({ x:0, y:0 });
      return toRefs(pos); //  {x: refObj, y: refObj}
    }

    function useBooks(){
      const books = ref([]);
      return {
        books // books is refObj
      }
    }

    function useLoginUser(){
      const user = readonly({
        isLogin: false,
        loginId: null
      });
      return toRefs(user); // { isLogin: refObj, loginId: refObj }  all ref is readonly
    }

    setup(){
      // 在setup函数中，尽量保证解构、展开出来的所有响应式数据均是ref
      return {
        ...usePos(),
        ...useBooks(),
        ...useLoginUser()
      }
    }
    ```

## 副作用

  - 在可组合函数中的确可以执行副作用（例如：添加DOM事件监听器或者请求数据），但请注意一下规则

    1.  如果在一个应用中使用了服务器端渲染（SSR），请确保在后置加载的声明钩子上执行 DOM 相关的副作用
