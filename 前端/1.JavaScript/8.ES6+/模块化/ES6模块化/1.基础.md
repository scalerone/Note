# 基础

## 介绍

- ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

- ES6 模块是编译时加载

- ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，再通过 `import` 命令输入

- 引擎处理 `import` 语句是在编译时，这时不会去分析或执行 `if` 语句，所以`import` 语句放在 `if` 代码块之中毫无意义，因此会报句法错误，而不是执行时错误

- `import` 和 `export` 命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）

    ```js
    // ES6模块
    import { stat, exists, readFile } from 'fs';
    ```

- 上面代码的实质是从 `fs` 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象

## 导入规则

- 模块的导出分为两种：**基本导出**和**默认导出**

- 可以将整个模块的导出现象成一个对象，**基本导出**的是该对象的每个属性，**默认导出**的是该对象的特殊属性 `default`

    ```js
    // 导出的结果：现象成一个对象
    {
      a: xxx,  // 基本导出
      b: xxx,  // 基本导出
      default: xxx,  // 默认导出
      c: xxx  // 基本导出
    }
    ```

- 基本导出可以有多个，默认导出只能有一个

- 基本导出**必须**有名字，默认导出由于有特殊名字，所有可以不用写名字

    ```js
    export const a = 1;  // 基本导出 a = 1
    export const b = function() {}  // 基本导出  b = function() {}
    export function method() {}  // 基本导出  method = function() {}

    const c = 3;
    export { c };  // 基本导出 c = 1
    export { c as temp };  // 基本导出 temp = 1

    // 默认导出
    export default 3;  // 默认导出 default = 3
    export default function() {}  // 默认导出 default = function() {}
    const c = 3;
    export { c as default }  // 默认导出 default = 3

    export { a, b, c as default }  // 基本导出 a = 1, b = function() {}， 默认导出 default = 3
    ```

## 导出规则

- 规则

    ```js
    import { a, b } from "模块路径";  // 导入属性 a、b，放到变量 a、 b 中
    import { a as temp1, b as temp2 } from "模块路径";  // 导入属性 a、b，放到变量 temp1、 temp2 中

    import { defaule as a } from "模块路径";  // 导入属性deault，放到变量 a 中
    import { defaule as a, b } from "模块路径";  // 导入属性deault、 b，放到变量 a 、b 中

    import c from "模块路径";  // 相当于 import { defaule as c } from "模块路径";

    import c, { a, b } from "模块路径";  // 相当于 import { defaule as c, a, b } from "模块路径";

    import * as obj from "模块路径";  // 将模块对象放入到变量 obj 中

    import "模块路径";  // 不导入任何内容，仅执行一次模块
    ```

- 导入细节

    1. ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部

    2. 不饿能将导入代码放置到判断/循环中

    3. 导入的内容放置到**常量**中，不可变更

    4. ES6 module 使用了**缓存**，保证每个模块仅加载一次

## 模块--严格模式

- 严格模式:ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";

- 严格模式主要有以下限制

    1. 变量必须声明后再使用

    2. 函数的参数不能有同名属性，否则报错

    3. 不能使用 `with` 语句

    4. 不能对只读属性赋值，否则报错

    5. 不能使用前缀 0 表示八进制数，否则报错

    6. 不能删除不可删除的属性，否则报错

    7. 不能删除变量 `delete prop`，会报错，只能删除属性 `delete global[prop]`

    8. `eval` 不会在它的外层作用域引入变量

    9. `eval` 和 `arguments` 不能被重新赋值

    10. `arguments` 不会自动反映函数参数的变化

    11. 不能使用 `arguments.callee`

    12. 不能使用 `arguments.caller`

    13. 禁止 `this` 指向全局对象

    14. 不能使用 `fn.caller` 和 `fn.arguments` 获取函数调用的堆栈

    15. 增加了保留字（比如 `protected`、`static` 和 `interface`）

    16. ES6 模块之中，顶层的 `this` 指向 `undefined` ，即不应该在顶层代码使用 `this`
